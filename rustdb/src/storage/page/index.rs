use crate::storage::{PageId, RecordId};
use std::cmp::Ordering;
use std::fmt::Debug;
use std::{mem, ptr};

#[derive(Debug, PartialEq)]
pub enum Node<K> {
    Internal(Internal<K>),
    Leaf(Leaf<K>),
}

impl<K> Node<K> {
    pub fn is_overflow(&self) -> bool {
        match self {
            Node::Internal(internal) => internal.is_overflow(),
            Node::Leaf(leaf) => leaf.is_overflow(),
        }
    }
    pub fn is_underflow(&self) -> bool {
        match self {
            Node::Internal(internal) => internal.is_underflow(),
            Node::Leaf(leaf) => leaf.is_underflow(),
        }
    }

    pub fn allow_insert(&self) -> bool {
        match self {
            Node::Internal(internal) => internal.allow_insert(),
            Node::Leaf(leaf) => leaf.allow_insert(),
        }
    }

    pub fn allow_delete(&self) -> bool {
        match self {
            Node::Internal(internal) => internal.allow_delete(),
            Node::Leaf(leaf) => leaf.allow_delete(),
        }
    }

    pub fn parent(&self) -> Option<PageId> {
        match self {
            Node::Internal(node) => node.parent(),
            Node::Leaf(node) => node.parent(),
        }
    }
    pub fn set_parent(&mut self, page_id: PageId) {
        match self {
            Node::Internal(node) => node.set_parent(page_id),
            Node::Leaf(node) => node.set_parent(page_id),
        }
    }

    pub fn page_id(&self) -> PageId {
        match self {
            Node::Internal(node) => node.page_id(),
            Node::Leaf(node) => node.page_id(),
        }
    }

    pub fn set_next(&mut self, page_id: PageId) {
        match self {
            Node::Internal(node) => node.set_next(page_id),
            Node::Leaf(node) => node.set_next(page_id),
        }
    }

    pub fn set_prev(&mut self, page_id: PageId) {
        match self {
            Node::Internal(node) => node.set_prev(page_id),
            Node::Leaf(node) => node.set_prev(page_id),
        }
    }

    pub fn set_page_id(&mut self, page_id: PageId) {
        match self {
            Node::Internal(internal) => internal.set_page_id(page_id),
            Node::Leaf(leaf) => leaf.set_page_id(page_id),
        }
    }
    pub fn max_size(&mut self) -> usize {
        match self {
            Node::Internal(internal) => internal.max_size(),
            Node::Leaf(leaf) => leaf.max_size(),
        }
    }

    pub fn assume_internal_ref(&self) -> &Internal<K> {
        match self {
            Node::Internal(internal) => internal,
            Node::Leaf(_) => unreachable!(),
        }
    }

    pub fn assume_leaf_ref(&self) -> &Leaf<K> {
        match self {
            Node::Internal(_) => unreachable!(),
            Node::Leaf(leaf) => leaf,
        }
    }
    pub fn assume_internal_mut(&mut self) -> &mut Internal<K> {
        match self {
            Node::Internal(internal) => internal,
            Node::Leaf(_leaf) => unreachable!(),
        }
    }

    pub fn assume_leaf_mut(&mut self) -> &mut Leaf<K> {
        match self {
            Node::Internal(_) => unreachable!(),
            Node::Leaf(leaf) => leaf,
        }
    }
    pub fn assume_internal(self) -> Internal<K> {
        match self {
            Node::Internal(internal) => internal,
            Node::Leaf(_) => unreachable!(),
        }
    }

    pub fn assume_leaf(self) -> Leaf<K> {
        match self {
            Node::Internal(_) => unreachable!(),
            Node::Leaf(leaf) => leaf,
        }
    }

    pub fn split(&mut self) -> (K, Node<K>)
    where
        K: Default + Clone,
    {
        match self {
            Node::Internal(ref mut internal) => {
                let (median_key, sibling) = internal.split();
                assert_eq!(sibling.header.size, sibling.kv.len() - 1);
                (median_key, Node::Internal(sibling))
            }
            Node::Leaf(ref mut leaf) => {
                let (median_key, sibling) = leaf.split();
                assert_eq!(sibling.header.size, sibling.kv.len());
                (median_key, Node::Leaf(sibling))
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct Header {
    pub size: usize,
    pub max_size: usize,
    pub parent: Option<PageId>,
    pub page_id: PageId,
    pub next: Option<PageId>,
    pub prev: Option<PageId>,
}

/**
 * Store `n` indexed keys and `n + 1` child pointers (page_id) within internal page.
 * Pointer PAGE_ID(i) points to a subtree in which all keys K satisfy:
 * K(i) <= K < K(i+1).
 * NOTE: Since the number of keys does not equal to number of child pointers,
 * the first key always remains invalid. That is to say, any search / lookup
 * should ignore the first key.
 *
 * Internal page format (keys are stored in increasing order):
 * ----------------------------------------------------------------------------------
 * | HEADER | KEY(1) + PAGE_ID(1) | KEY(2) + PAGE_ID(2) | ... | KEY(n) + PAGE_ID(n) |
 * ----------------------------------------------------------------------------------
 */

#[derive(Debug, Clone, PartialEq)]
pub struct Internal<K> {
    pub header: Header,
    pub kv: Vec<(K, PageId)>,
}

impl<K> Internal<K> {
    pub fn search(&self, key: &K) -> (usize, PageId)
    where
        K: Ord,
    {
        let (mut start, mut end) = (1, self.header.size);
        while start < end {
            let mid = (start + end) / 2;
            match self.kv[mid].0.cmp(key) {
                Ordering::Less => {
                    start = mid + 1;
                }
                Ordering::Equal => return (mid, self.kv[mid].1),
                Ordering::Greater => {
                    end = mid - 1;
                }
            }
        }
        match key.cmp(&self.kv[start].0) {
            Ordering::Less => (start - 1, self.kv[start - 1].1),
            _ => (start, self.kv[start].1),
        }
    }

    pub fn is_overflow(&self) -> bool {
        // the max length of the key is m - 1
        self.header.size + 1 > self.header.max_size
    }

    pub fn is_underflow(&self) -> bool {
        // the max length of the key is m - 1
        self.parent().is_some() && self.header.size + 1 < self.header.max_size / 2
    }

    pub fn allow_insert(&self) -> bool {
        self.header.size + 1 < self.header.max_size
    }

    pub fn allow_delete(&self) -> bool {
        self.parent().is_none() || self.header.size + 1 > self.header.max_size / 2
    }

    pub fn max_size(&self) -> usize {
        self.header.max_size
    }

    pub fn page_id(&self) -> PageId {
        self.header.page_id
    }
    pub fn set_page_id(&mut self, page_id: PageId) {
        self.header.page_id = page_id
    }

    pub fn set_parent(&mut self, page_id: PageId) {
        self.header.parent = Some(page_id);
    }

    pub fn parent(&self) -> Option<PageId> {
        self.header.parent
    }

    pub fn set_next(&mut self, page_id: PageId) {
        self.header.next = Some(page_id);
    }

    pub fn next(&self) -> Option<PageId> {
        self.header.next
    }

    pub fn set_prev(&mut self, page_id: PageId) {
        self.header.prev = Some(page_id);
    }

    pub fn prev(&self) -> Option<PageId> {
        self.header.prev
    }

    pub fn split(&mut self) -> (K, Internal<K>)
    where
        K: Default,
    {
        // index 0 is ignored, so we split kv from max_size/2 +1
        let spilt_at = self.header.max_size / 2 + 1;

        let mut sibling_kv = self.kv.split_off(spilt_at);
        let median_key = mem::take(&mut sibling_kv[0].0);
        let mut sibling_header = self.header.clone();
        self.header.size = self.kv.len() - 1;
        sibling_header.size = sibling_kv.len() - 1;
        (
            median_key,
            Internal {
                header: sibling_header,
                kv: sibling_kv,
            },
        )
    }

    pub fn insert(&mut self, index: usize, k: K, page_id: PageId) {
        self.kv.insert(index, (k, page_id));
        self.header.size += 1;
    }

    pub fn steal_first(&mut self) -> Option<(K, PageId)> {
        if self.allow_steal() {
            let (key, val) = self.kv.remove(0);
            self.header.size -= 1;
            let key = mem::replace(&mut self.kv[0].0, key);
            return Some((key, val));
        }
        None
    }

    pub fn push_front(&mut self, key: K, val: PageId) {
        self.kv.insert(0, (key, val));
        let pa = ptr::addr_of_mut!(self.kv[0].0);
        let pb = ptr::addr_of_mut!(self.kv[1].0);
        unsafe {
            ptr::swap(pa, pb);
        }
        self.header.size += 1;
    }

    pub fn merge(&mut self, key: K, sibling: &mut Internal<K>) {
        sibling.kv[0].0 = key;
        self.kv.append(&mut sibling.kv);
        self.header.size += sibling.header.size + 1;
        self.header.next = sibling.header.next;
    }

    pub fn steal_last(&mut self) -> Option<(K, PageId)> {
        if self.allow_steal() {
            self.header.size -= 1;
            return self.kv.pop();
        }
        None
    }

    pub fn push_back(&mut self, key: K, val: PageId) {
        self.kv.push((key, val));
        self.header.size += 1;
    }

    pub fn allow_steal(&self) -> bool {
        self.header.size > self.header.max_size / 2
    }
}

/**
 * Store indexed key and record id (record id = page id combined with slot id,
 * see `include/common/rid.h` for detailed implementation) together within leaf
 * page. Only support unique key.
 *
 * Leaf page format (keys are stored in order):
 * -----------------------------------------------------------------------
 * | HEADER | KEY(1) + RID(1) | KEY(2) + RID(2) | ... | KEY(n) + RID(n)  |
 * -----------------------------------------------------------------------
 *
 * Header format (size in byte, 16 bytes in total):
 * -----------------------------------------------------------------------
 * | PageType (4) | CurrentSize (4) | MaxSize (4) | NextPageId (4) | ... |
 * -----------------------------------------------------------------------
 */

#[derive(Debug, Clone, PartialEq)]
pub struct Leaf<K> {
    pub header: Header,
    pub kv: Vec<(K, RecordId)>,
}
impl<K> Leaf<K> {
    pub fn search(&self, key: &K) -> Option<RecordId>
    where
        K: Ord,
    {
        match self.kv.binary_search_by(|(k, _)| k.cmp(key)) {
            Ok(index) => Some(self.kv[index].1),
            Err(_) => None,
        }
    }

    pub fn is_overflow(&self) -> bool {
        self.header.size > self.header.max_size - 1
    }

    pub fn is_underflow(&self) -> bool {
        self.parent().is_some() && self.header.size < self.header.max_size / 2
    }

    pub fn allow_insert(&self) -> bool {
        self.header.size < self.header.max_size - 1
    }

    pub fn allow_delete(&self) -> bool {
        self.header.size > self.header.max_size / 2
    }

    pub fn max_size(&self) -> usize {
        self.header.max_size
    }

    pub fn page_id(&self) -> PageId {
        self.header.page_id
    }
    pub fn set_page_id(&mut self, page_id: PageId) {
        self.header.page_id = page_id
    }

    pub fn set_parent(&mut self, page_id: PageId) {
        self.header.parent = Some(page_id);
    }

    pub fn parent(&self) -> Option<PageId> {
        self.header.parent
    }

    pub fn set_next(&mut self, page_id: PageId) {
        self.header.next = Some(page_id);
    }

    pub fn next(&self) -> Option<PageId> {
        self.header.next
    }

    pub fn set_prev(&mut self, page_id: PageId) {
        self.header.prev = Some(page_id);
    }

    pub fn prev(&self) -> Option<PageId> {
        self.header.prev
    }

    pub fn remove(&mut self, key: &K) -> Option<(K, RecordId)>
    where
        K: Ord,
    {
        match self.kv.binary_search_by(|(k, _)| k.cmp(key)) {
            Ok(index) => {
                self.header.size -= 1;
                let val = self.kv.remove(index);
                Some(val)
            }
            Err(_) => None,
        }
    }

    pub fn split(&mut self) -> (K, Leaf<K>)
    where
        K: Clone,
    {
        let spilt_at = self.header.max_size / 2;
        let sibling_kv = self.kv.split_off(spilt_at);
        let median_key = sibling_kv[0].0.clone();
        let mut sibling_header = self.header.clone();
        self.header.size = self.kv.len();
        sibling_header.size = sibling_kv.len();
        (
            median_key,
            Leaf {
                header: sibling_header,
                kv: sibling_kv,
            },
        )
    }

    pub fn insert(&mut self, index: usize, k: K, record_id: RecordId) {
        self.kv.insert(index, (k, record_id));
        self.header.size += 1;
    }

    pub fn merge(&mut self, sibling: &mut Leaf<K>) {
        self.kv.append(&mut sibling.kv);
        self.header.size += sibling.header.size;
        self.header.next = sibling.header.next;
    }

    pub fn steal_first(&mut self) -> Option<(K, RecordId)> {
        if self.allow_steal() {
            self.header.size -= 1;
            return Some(self.kv.remove(0));
        }
        None
    }

    pub fn push_front(&mut self, key: K, val: RecordId) {
        self.kv.insert(0, (key, val));
        self.header.size += 1;
    }

    pub fn steal_last(&mut self) -> Option<(K, RecordId)> {
        if self.allow_steal() {
            self.header.size -= 1;
            return self.kv.pop();
        }
        None
    }

    pub fn push_back(&mut self, key: K, val: RecordId) {
        self.kv.push((key, val));
        self.header.size += 1;
    }

    pub fn allow_steal(&self) -> bool {
        self.header.size > self.header.max_size / 2
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::encoding;
    use crate::encoding::{Decoder, Encoder};
    use crate::error::RustDBResult;
    use crate::storage::PAGE_SIZE;
    use bytes::{Buf, BufMut};

    #[derive(PartialEq, Debug)]
    struct Key {
        data: u32,
    }

    impl Encoder for Key {
        fn encode<B>(&self, buf: &mut B) -> Result<(), encoding::error::Error>
        where
            B: BufMut,
        {
            buf.put_u32(self.data);
            Ok(())
        }
    }

    impl Decoder for Key {
        fn decode<B>(buf: &mut B) -> Result<Self, encoding::error::Error>
        where
            B: Buf,
        {
            Ok(Self {
                data: buf.get_u32(),
            })
        }
    }

    #[test]
    fn test_header_decode_encode() -> RustDBResult<()> {
        let header = Header {
            size: 1,
            max_size: 2,
            parent: None,
            page_id: 4,
            next: Some(5),
            prev: Some(6),
        };
        let mut buffer = [0; PAGE_SIZE];
        header.encode(&mut buffer.as_mut())?;
        let new_header1 = Header::decode(&mut buffer.as_ref())?;
        let new_header2 = Header::decode(&mut buffer.as_ref())?;
        assert_eq!(header, new_header1);
        assert_eq!(header, new_header2);
        Ok(())
    }

    #[test]
    fn test_internal_decode_encode() -> RustDBResult<()> {
        let len = 100;
        let mut kv = Vec::with_capacity(len);
        for i in 0..len {
            kv.push((Key { data: i as u32 }, i))
        }
        let tree = Node::Internal(Internal {
            header: Header {
                size: len - 1,
                max_size: len,
                parent: Some(1),
                page_id: 2,
                next: Some(5),
                prev: Some(6),
            },
            kv,
        });

        let mut buffer = [0; PAGE_SIZE];
        tree.encode(&mut buffer.as_mut())?;
        let new_tree: Node<Key> = Node::decode(&mut buffer.as_ref())?;
        assert_eq!(new_tree, tree);
        tree.encode(&mut buffer.as_mut())?;
        let new_tree2: Node<Key> = Node::decode(&mut buffer.as_ref())?;
        assert_eq!(new_tree, new_tree2);
        Ok(())
    }

    #[test]
    fn test_leaf_decode_encode() -> RustDBResult<()> {
        let len = 100;
        let mut kv = Vec::with_capacity(len);
        for i in 0..len {
            kv.push((
                Key { data: i as u32 },
                RecordId {
                    page_id: i,
                    slot_num: i as _,
                },
            ))
        }
        let tree = Node::Leaf(Leaf {
            header: Header {
                size: len,
                max_size: len,
                parent: Some(2),
                page_id: 3,
                next: Some(9),
                prev: Some(8),
            },
            kv,
        });

        let mut buffer = [0; PAGE_SIZE];
        tree.encode(&mut buffer.as_mut())?;
        let new_tree: Node<Key> = Node::decode(&mut buffer.as_ref())?;
        assert_eq!(new_tree, tree);
        tree.encode(&mut buffer.as_mut())?;
        let new_tree2: Node<Key> = Node::decode(&mut buffer.as_ref())?;
        assert_eq!(new_tree, new_tree2);
        Ok(())
    }

    #[tokio::test]
    async fn test_simple_encode() {
        let data: [u8; 4096] = [
            2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 255, 255, 255, 255, 255, 255, 255, 255, 0, 0, 0, 1,
            0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0,
            0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        ];
        let node: Node<u32> = Node::decode(&mut data.as_ref()).unwrap();
        assert_eq!(node.page_id(), 0);
    }
}
